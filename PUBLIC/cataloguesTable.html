<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title></title>

	<link rel="stylesheet" href="http://emlo.bodleian.ox.ac.uk/css/app.css" />
	<script src="http://emlo.bodleian.ox.ac.uk/bower_components/modernizr/modernizr.min.mat.js"></script>

	<style>
		th { text-align: left; }
		th, td { padding: 0 1em 0.5ex 0;}
		th.center, td.center { text-align: center; }
		th.num, td.num { text-align: right; }
	</style>
</head>

	<body>

		<label for="from-year">From <input id="from-year" value="1600"/></label>
		<label for="to-year">To <input id="to-year"/></label><br/>
		<table id="cat"></table>

		<script src="lib/d3.min.js"></script>
		<script src="lib/d3.slider.js"></script>
		<script src="data/catalogues.js"></script>
		<script src="http://emlo.bodleian.ox.ac.uk/js/catalogue-blog.js"></script>
		<script src="cataloguesYears.js"></script>
		<script>

			var dget = function(member) { return function(d) {return d[member]}; };

			var dataPostgres = catalogueYearsCount,
				dataTemp = {}, i;

			var undated = timeline.noYear;

			//
			// Sort out data
			//
			for( i=0; i < dataPostgres.length; i++ ) {
				var yearData = dataPostgres[i],
						catalogueName = yearData["Catalogue"];

				if( ! (catalogueName in dataTemp) ) {
					dataTemp[catalogueName] = {
						start : 2000,
						end : 0,
						id : yearData["CatalogueId"],
						count: 0
					};

					dataTemp[catalogueName][undated] = 0;
				}

				if( yearData.year === "" ) {
					yearData.year = undated; //dummyYear; // A crafty cheat for entries without years. (That will no doubt come back and bite me...)
				}

				// Create an entry for each year
				dataTemp[catalogueName][yearData.year] = yearData.number;
				dataTemp[catalogueName].count += yearData.number;

				if( yearData.year !== undated) {

					if (yearData.year < dataTemp[catalogueName]["start"]) {
						dataTemp[catalogueName]["start"] = yearData.year;
					}

					if (yearData.year > dataTemp[catalogueName]["end"]) {
						dataTemp[catalogueName]["end"] = yearData.year;
					}
				}
			}

			var catalogueNames = Object.keys( dataTemp );
			var catalogueList = [], catalogueListFull;

			catalogueNames.forEach( function(name) {
				var catData = dataTemp[name];
				catData.name = name;
				catalogueList.push(catData);
			});


			// Debug
			catalogueList = catalogueList.slice(0,3);


			catalogueListFull = catalogueList.slice(0);

			var minYear = d3.min( catalogueList, dget('start') ),
				maxYear = d3.max( catalogueList, dget('end') );

			d3.select("input#from-year").attr("value", minYear );
			d3.select("input#to-year").attr("value", maxYear );

			var sort = "nameAsc";
			catalogueList.sort( orderBy( sort ) );

			var columns = [
				{ id: 'name', head: 'Catalogue Name ▼', cl: 'title',
					html: function(row) { return row.name; } },
				{ id: 'start', head: 'Year Start  ', cl: 'center',
					html: function(row) { return row.start; } },
				{ id: 'end', head: 'Year End  ', cl: 'center',
					html: function(row) { return row.end; } },
				{ id: 'dated', head: 'Dated  ', cl: 'num',
					html: function(row) { return (row[undated]) ? row.count - row[undated] : row.count; } },
				{ id: 'undated', head: 'Undated  ', cl: 'num',
					html: function(row) { return row[undated]; } },
				{ id: 'total', head: 'Total  ', cl: 'num',
					html: function(row) { return row.count; } }
			];

			var table = d3.select("table#cat");

			table.append('thead').append('tr')
				.selectAll('th')
				.data(columns).enter()
				.append('th')
				.attr('class', function(d) { return d.cl; } )
				.text(function(d) { return d.head; } );

			table.append('tbody')
				.selectAll('tr')
				.data(catalogueList, function(d,i){return i/*d.id*/;}).enter()
				.append('tr')
				.classed('cat', 1)
				.style('opacity', '1' )
				.selectAll('td')
				.data(function(row, i) {
					// evaluate column objects against the current row
					return columns.map(function(c) {
						var cell = {};
						d3.keys(c).forEach(function(k) {
							cell[k] = (typeof c[k] === 'function') ? c[k](row,i) : c[k];
						});
						return cell;
					});
				}).enter()
					.append('td')
					.html(function(d){return d.html;})
					.attr('class', function(d){return d.cl;});


			var previousFilter = {from:-1,to:-1};
			function filterByYear() {
				console.log("filterByYear");

				var filterYearFromText = document.getElementById("from-year").value,
					filterYearToText   = document.getElementById("to-year").value;

				var filterYearFrom = getYear( filterYearFromText ),
					filterYearTo   = getYear( filterYearToText );

				/*if( filterYearFromText !== '' && filterYearFrom !== 0 ) {
					// If it's not blank but not recognised use previous version
					filterYearFrom = previousFilter.from;
				}
				if( filterYearToText!== '' && filterYearTo !== 0 ) {
					// If it's not blank but not recognised use previous version
					filterYearTo = previousFilter.to;
				}*/

				var from = (filterYearFrom !== 0),
					to   = (filterYearTo !== 0);

				if( filterYearFrom !== previousFilter.from || filterYearTo !== previousFilter.to) {

					previousFilter.from =  from ? filterYearFrom : previousFilter.from;
					previousFilter.to   =  to ? filterYearTo : previousFilter.to;

					if (false) { //!from && !to) {
						//catalogueList = catalogueListFull.slice(0);
					}
					else {
						catalogueList = catalogueListFull.filter(function (cat) {

							var keep = false;
							var fromAfterStart = filterYearFrom >= cat.start,
								toAfterStart = filterYearTo >= cat.start,
								fromAfterEnd = filterYearFrom > cat.end,
								toAfterEnd = filterYearTo > cat.end;
							/*
						OK:
						    f   t
							|   |     !fromAfterStart && toAfterStart && !fromAfterEnd && !toAfterEnd 0100
							  s+++e

				  	        |   |     fromAfterStart && toAfterStart && !fromAfterEnd && toAfterEnd 1101
						  s+++e

							|   |     fromAfterStart && toAfterStart && !fromAfterEnd && !toAfterEnd 1100
						   s+++++e

							|   |     !fromAfterStart && toAfterStart && !fromAfterEnd && toAfterEnd 0101
							 s+e
				        */

							if (from && !to) {
								if (!fromAfterEnd) {
									keep = true;
								}
							}
							else if (!from && to) {
								if (toAfterStart) {
									keep = true;
								}
							}
							if (from && to) {
								if (
									(!fromAfterStart && toAfterStart && !fromAfterEnd && !toAfterEnd) ||
									(fromAfterStart && toAfterStart && !fromAfterEnd && toAfterEnd) ||
									(fromAfterStart && toAfterStart && !fromAfterEnd && !toAfterEnd) ||
									(!fromAfterStart && toAfterStart && !fromAfterEnd && toAfterEnd)
								) {
									keep = true;
								}
							}

							return keep;
						});
					}
				}
			}

			d3.select('input#from-year').on("input",function() {
				filterByYear();
				updateData();
			});
			d3.select('input#to-year').on("input",function() {
				filterByYear();
				updateData();
			});

			filterByYear();
			setTimeout( function() {
				updateData();
			}, 1000);

			/*catalogueList.sort( orderBy( "nameDesc" ) );
			setTimeout( function() {
				updatePosition();

				catalogueList = catalogueList.splice(5,10);
				setTimeout( function() {
					updateData();

					catalogueList.sort( orderBy( "nameAsc" ) );

					setTimeout( function() {
						updatePosition();
					}, 1000);
				}, 1000);

			}, 1000 );*/


			function updatePosition() {
				var selection = table.select("tbody")
					.selectAll('tr')
					.data(catalogueList, function(d,i) {
						return i;
					});

				var selectionTd = selection
					.selectAll('td');

				var timing = 300;

				selectionTd
					.transition()
					.duration(timing)
					.style('opacity', 0.5 );

				setTimeout( function() {
					selectionTd
						.data(function (row, i) {
							// evaluate column objects against the current row
							return columns.map(function (c) {

								var cell = {};
								d3.keys(c).forEach(function (k) {
									cell[k] = (typeof c[k] === 'function') ? c[k](row, i) : c[k];
								});
								return cell;
							});
						})
						.html(function (d) {
							return d.html;
						})
						.attr('class', function (d) {
							return d.cl;
						})
				}, timing);

				selectionTd
					.transition()
					.delay(timing+50)
					.duration(300)
					.style('opacity', 1 );

				table.select('thead').select('tr')
					.selectAll('th')
					.data(columns)
					.text(function(d) { return d.head; } );
			}

			function updateData() {

				console.log("update");

				var selection = table.select("tbody")
					.selectAll('tr')
					.data(catalogueList, function(d,i) {
						return d.id;
					});

				selection.enter()
					.append('tr')
					.classed('cat',1)
					.selectAll('td')
					.data(function (row, i) {
						// evaluate column objects against the current row
						return columns.map(function (c) {
							var cell = {};
							d3.keys(c).forEach(function (k) {
								cell[k] = (typeof c[k] === 'function') ? c[k](row, i) : c[k];
							});
							return cell;
						});
					}).enter()
						.append('td')
						.html(function (d) {
							return d.html;
						})
						.attr('class', function (d) {
							return d.cl;
						});

				selection
					.selectAll('td')
					.data(function (row, i) {
						// evaluate column objects against the current row
						return columns.map( function (c) {

							var cell = {};
							d3.keys(c).forEach(function (k) {
								cell[k] = (typeof c[k] === 'function') ? c[k](row, i) : c[k];
							});
							return cell;
						});
					})
					.html(function (d) {
						return d.html;
					})
					.attr('class', function (d) {
						return d.cl;
					});

				selection.exit()
					.classed('remove',1)
					.transition()
					.duration(500)
					.style('opacity', 0 )
					//.transition()
					//.style("display", "inline-block")
					//.transition()
					//.duration(1000)
					//.style("height", 0)
					.remove();

			}

			function getYear( year ) {
				year = +year;
				if( !isNaN(year) ) {
					if( year >= minYear && year <= maxYear ) {
						return year;
					}
				}

				return 0;
			}

			// Column ordering
			d3.selectAll("#cat th").on("click", function( pushed ) {
				console.log(pushed);
				if( pushed.id === 'name') {
					sort = (sort === "nameAsc") ? "nameDesc" : "nameAsc";
				}
				else if( pushed.id === 'start') {
					sort = (sort === "startAsc") ? "startDesc" : "startAsc";
				}
				else if( pushed.id === 'end') {
					sort = (sort === "endAsc") ? "endDesc" : "endAsc";
				}
				else if( pushed.id === 'dated') {
					sort = (sort === "datedAsc") ? "datedDesc" : "datedAsc";
				}
				else if( pushed.id === 'undated') {
					sort = (sort === "undatedAsc") ? "undatedDesc" : "undatedAsc";
				}
				else if( pushed.id === 'total') {
					sort = (sort === "totalAsc") ? "totalDesc" : "totalAsc";
				}

				columns.forEach( function(column) {
					if( pushed.head === column.head ) {
						column.head = column.head.substring( 0, column.head.length - 1 );

						if( sort.substring( sort.length-3 ) === "Asc" ) {
							column.head += "▼";
						}
						else {
							column.head += "▲";
						}
					}
					else {
						column.head = column.head.substring( 0, column.head.length - 1 ) + ' ';
					}
				});


				order( sort );
				updatePosition();
			});

			function order( by ) {
				catalogueList.sort( orderBy( by ) );
			}

			function orderBy( by ) {
				/* Change the order of "data". */
				if( by === "nameAsc" || by === "nameDesc" ) {
					return generateSort( function(o) {return o.name;}, by === "nameAsc" );
				}
				else if( by === "startAsc" || by === "startDesc" ) {
					return generateSort( function(o) {return o.start;}, by === "startAsc" );
				}
				else if( by === "endAsc" || by === "endDesc" ) {
					return generateSort( function(o) {return o.end;}, by === "endAsc" );
				}
				else if( by === "datedAsc" || by === "datedDesc" ) {
					return generateSort( function(o) { return (o[undated]) ? o.count - o[undated] : o.count; }, by === "datedAsc" );
				}
				else if( by === "undatedAsc" || by === "undatedDesc" ) {
					return generateSort( function(o) {return o[undated];}, by === "undatedAsc" );
				}
				else if( by === "totalAsc" || by === "totalDesc" ) {
					return generateSort( function(o) {return o.count;}, by === "totalAsc" );
				}

				function generateSort( memberFunction, ascending ) {
					/* Generate a sort function with particular features */
					return function(a,b) {
						var compare = ((memberFunction(a) < memberFunction(b)) ? -1 : memberFunction(a) > memberFunction(b));
						if(compare===0) {
							compare = ( (a.name < b.name) ? -1 : a.name > b.name );
						}
						return (ascending) ? compare : compare*-1;
					};
				}
			}

		</script>
	</body>

</html>